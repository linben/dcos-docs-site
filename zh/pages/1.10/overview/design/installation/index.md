---
layout: layout.pug
excerpt:
title: >
    Design: Installation
navigationTitle: Installation
menuWeight: 4
---

构建，安装和操作DC/OS必须是一个可重复的过程。 当操作10,000台主机时，即使很小的错误概率也是不可接受的。 由于DC/OS由30多个不同的库，服务和支持包组成，因此需要使用非标准方法。如果将这些组件中的每一个作为独立的组件在目标主机上进行安装和配置，会导致系统的故障。

受许多成熟操作系统的启发，构建一个坚固的系统。一旦构建过程完成，您将得到一个包含安装和运行所需的所有组件的工件。 这看起来非常类似于您最终用来安装您最喜爱的Linux发行版的ISO。

有一个简单的工件允许我们做一些假设和保证。

- 每个主机都是完全相同的，它们只是具有不同的角色，并使用不同的子组件。
- 升级是原子性的，不会导致奇怪的组件不兼容。
- 下载不依赖于多个不同的来源，因为只有一个文件，验证完整性和是否损坏非常容易.

## 设计目标

在我们深入了解一切工作之前，让我们明确设计目标。 了解您正在使用的最终体系结构和设计的约束条件非常重要。

- 尽可能减小对于主机操作系统的依赖。这样能使DC/OS运行于更多的环境。
- 主机操作系统应该是完全可定制的。每个人都有一套正在使用的不同工具。这些工具应该不做任何个性就可移植。当涉及硬件特定的东西，如内核模块，这是很重要的。
- 主机上的依赖关系应该被最小化。很难控制并依赖主机启动的顺序（主节点，代理节点）。他们应该能够以任何顺序启动，只有在他们的依赖被处理和提供给集群时才开始工作。
- 最小化外部基础设施依赖。像PXE启动镜像和NFS存储这样的外部基础设施很少存在。
- 应该可以选择部署方法。您习惯于现有的系统，没有必要去学习新的。整合应该有一个干净的界面，尽可能最小。
- DC/OS与现有系统，如配置管理工具和CloudFormation，之间的集成应尽可能简单。集成接口必须简单，且有完备的文档。
- 所有的依赖关系和库应该被捆绑成一个单一的工件。正常的生命周期流程将完全升级或降级DC/OS之外的库和依赖项。通过不依赖这些，系统变得不脆弱以及更稳定。
- 如有必要，用户应该能够在实时更改系统中代码和配置。虽然这是一种非正常模式，但偶尔可以帮助您在关键时刻保证基础架构可用。
- 安装必须尽可能接近100％。即使1％的故障最终导致了10个故障情况，当您运行1000个主机集群时就需要手动干预。
- 升级和回滚升级在主机上必须是原子级的。
- 集群的状态必须是可监控的。当运行大型集群时，很容易陷入一个难以依赖单个主机状态的情况。


## 打包

我们选择tarball作为打包格式是因为它可以用在任何地方。tarball是一种可压缩的文件格式，可将多个文件一起打包成单个压缩文件。虽然有很多常见的封装格式（deb，rpm，wheel，gem，jar等），但它们都只是包装下的tarball。不幸的是，几乎所有的常见格式都是围绕一个发行版或语言构建的，这使得它们很难在其他发行版和语言之间使用。某些功能（如安装前和安装后脚本）非常方便，可以帮助将系统配置为正确的“状态”。这不值得，有可能带来不可预测的结果和/或未经测试的极端情况。因此，我们简化了包装安装这一步：tarball提取。没有任何代码执行和保证可重复性。

DC/OS中的所有组件都放在一个tarball中，最终被提取到主机系统上的`/opt/mesosphere`。 在这个目录里，您最终会看到很像`/usr/local`的东西。每个组件都位于自己的软件包目录中，然后将重要的文件链接到像`bin`和`lib`这样的重要目录。


## 构建

主要构件必须以某种方式组装。由于DC/OS是由不断变化的组件列表组成的，因此构建工具看起来就像是自己的包管理器。每个组件必须从源代码构建，以可重复的方式进行配置，然后添加到主要工件中。

DC/OS包由两个文件定义：[`build`][1]和[`buildinfo.json`][2]。 这些说明需要下载什么以及如何构建它。在构建时，工具链负责构建，打包并包含主tarball中所需的所有工件。


## 安装

现在有一个包含所有运行DC/OS的内置组件的软件包，每次安装都必须先配置好才能放置在主机上。通过保持这种小而不可变的配置，可以确保集群中的每台主机都以相同的方式运行。

使用配置工具，所有组件都内置到一个包中，其中包含所有可以运行集群的组件。你会从一个小的列表中选择DNS配置和引导信息。然后将其添加到之前构建的单个压缩包中。然后，您将拥有一个为您的硬件定制的软件包，并可重复创建任意大小的集群。

编排安装的部署非常困难，特别是当您需要按照特定顺序执行操作时。为了尽可能简单，在主机级别，DC/OS不会假设集群的状态。您可以先安装代理节点，然后主节点，或是同时安装两个！

软件包构建好之后，您可以在每台主机上运行`dcos_install.sh`。这个脚本只做以下3件事:

- 在当前主机上下载软件包.
- 将软件包解压到`/opt/mesosphere`目录中.
- 使用[DC/OS组件包管理器(Pkgpanda)](/1.10/overview/architecture/components/#dcos-component-package-manager) 初始化安装.

就是这样！一旦ZooKeeper主节点集群达到法定数量，Mesos启动，代理节点就可以加入集群，您可以开始使用。我们尽量减少步骤，确定它是可依赖的.


## 权衡

显然，还有其他方法可以构建。让我们来看看一些常见的问题，以及为什么用现在的方法。


## 不可变的配置

每个集群的配置在开始时生成，之后不可变。这使我们可以保证安装后每台主机上的配置都是正确的。请记住，您将会为成千上万的节点做这件事。这些配置文件保证减少了运行DC/OS所需的文档数量，使其更易于支持。

使用不可变的配置，主机不可能更新/更改配置。 我们遇到的许多生产问题都是通过这个设计决定来解决的。更多信息，请参阅Joe Smith[关于在Twitter生产环境中运行Mesos](https://www.youtube.com/watch?v=nNrh-gdu9m4) 介绍。

### 需要绑定到那个IP?

决定访问网络和Mesos主机的IP和网络接口是非常重要的。以下环境，我们无法使用默认设置：

- 在像水平分割环境中，如AWS，主机名可能会解析为外部IP地址而不是内部IP地址。
- 在没有DNS的环境中，我们需要你告诉我们它是什么IP。
- 在具有多个接口的环境中，我们无法自动选择使用哪个接口。
- 并不是所有的机器都有可解析的主机名，所以你不能做反向查询

Because of these constraints, we’ve struggled to produce a solid default. To make it as configurable as possible, we have a script that can be written to return the IP address we should bind to on every host. There are multiple examples in the documentation of how to write `ip-detect` for different environments which should cover most use cases. For those that the default doesn’t work, you will be able to write your own `ip-detect` and integrate it with your configuration. `ip-detect` is the most important part of the configuration and the only way your clusters will be able to come up successfully.
由于这些限制，我们一直在努力找到一个稳定的默认值。为了使其尽可能可配置，我们写了有一个脚本，以返回我们应该绑定到每台主机的IP地址。关于如何为不同的环境编写`ip-detect`的文档有很多例子，它们应该涵盖大多数的用例。对于那些默认不起作用的，您将能够编写自己的`ip-detect`并将其与您的配置集成在一起。`ip-detect`是配置中最重要的部分，也是您的集群能够成功配置的唯一方式。

### 单个或多个包，预定义软件包 (RPM, DEB等等)

不把所有的软件包捆绑在一起成为一个映像，我们可以使用目前最常用的方式，并单独安装。 有一些问题立即出现：

- 在不同的发行版之间使用需要移植和测试软件包。
- 软件包安装具有非零故障率。 试图安装软件包时，我们看到10-20％的失败率。 这样导致集群无法成功启动并使其更难操作。
- 传送多个软件包要比单个压缩包分发困难得多。 在确保多个软件包健壮的情况下，开销很大。
- 升级必须是原子的。多个包确保这一点要困难得多。

### Tarball 与容器

可以将DC/OS打包为大量容器（或具有多个进程的单个容器）。这将多个软件包的缺点与Docker守护进程的不稳定性相结合。我们发现Docker守护进程经常崩溃，虽然这对于某些应用程序是可以接受的，但这不是基础架构的方式l。

### 安装方法

我们可以支持任何的安装方法。目前使用的很多的配置和包管理方法是可怕的。我们看了很多工具，从Puppet到定制的内部工具。 我们希望通过提供一个简单的界面，让其能与尽可能多的工具配合工作。 这里最通用的是bash。

由于难以维护bash，我们尽可能简化了安装方法。 构建的“镜像”可以放在运行主机并独立运行。要安装它，只需要提取。这是一个小而简单的bash脚本，可以在任何地方工作，并可以轻松地与其他工具集成。整个暴露的东西是非常小，并不允许访问内部，如果更改将使您的集群不被支持，没有任何保障。

### 主机镜像

可以构建配置好的主机映像，而不是tarball。让我们看看为什么这个安装方法是没有意义的：

- 我们最终会亡于发行版更新。每次RHEL发布软件包更新时，我们都需要测试，打包和发布。 CoreOS变得更加困难，我们最终将亡于复制项目。
- 您想选择自己的发行版。 一些可以得到Canonical和RedHat的支持。
- 您想配置基本的操作系统。有一些安全策略和配置必须应用于主机。

使用主机镜像是一个非常好的发行和安装DC/OS的方法。通过提供bash安装方法，为您的基础设施创建新的主机映像就像使用Puppet这样的工具进行集成一样简单。

### 为用户直接暴露配置文件

DC/OS中包含的组件具有大量的配置选项。我们花了很长时间找到正确的。这些选项保证给您在生产规模最优的配置。如果我们要公开这些选项，就会增加运行DC/OS集群所需的知识。

请记住，对于软件包安装而言，集群大部分看起来几乎相同。只要框架所依赖的配置参数发生变化，我们就无法保证软件包能够可靠地安装和运行。

[1]: https://github.com/dcos/dcos/blob/master/packages/mesos/build
[2]: https://github.com/dcos/dcos/blob/master/packages/mesos/buildinfo.json
